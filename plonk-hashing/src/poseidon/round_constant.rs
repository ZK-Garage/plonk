use alloc::collections::vec_deque::VecDeque;
use ark_ff::{BigInteger, PrimeField};
/// From the paper
/// THe parameter describes the initial state of constant generation (80-bits)
/// * `field`: description of field. b0, b1
/// * `sbox`: description of s-box. b2..=b5
/// * `field_size`: binary representation of field size. b6..=b17
/// * `t`: binary representation of t. b18..=b29
/// * `rf`: binary representation of rf. b30..=b39
/// * `rp`: binary representation of rp. b40..=b49
/// * `ones`: set to 1. b50..=b79
pub fn generate_constants<F: PrimeField>(
    field: u8,
    sbox: u8,
    field_size: u16,
    t: u16,
    r_f: u16,
    r_p: u16,
) -> Vec<F> {
    let n_bytes = (F::size_in_bits() + 8 - 1) / 8;
    if n_bytes != 32 {
        unimplemented!("neptune currently supports 32-byte fields exclusively");
    };
    assert_eq!((field_size as f32 / 8.0).ceil() as usize, n_bytes);

    // r_f here is 2* number of *half* full rounds.
    let num_constants = (r_f + r_p) * t;
    let mut init_sequence: VecDeque<bool> = VecDeque::new();
    append_bits(&mut init_sequence, 2, field); // Bits 0-1
    append_bits(&mut init_sequence, 4, sbox); // Bits 2-5
    append_bits(&mut init_sequence, 12, field_size); // Bits 6-17
    append_bits(&mut init_sequence, 12, t); // Bits 18-29
    append_bits(&mut init_sequence, 10, r_f); // Bits 30-39
    append_bits(&mut init_sequence, 10, r_p); // Bits 40-49
    append_bits(&mut init_sequence, 30, 0b111111111111111111111111111111u128); // Bits 50-79

    let mut grain = GrainLFSR::new(init_sequence, field_size);
    let mut round_constants: Vec<F> = Vec::new();

    match field {
        1 => {
            for _ in 0..num_constants {
                while {
                    // TODO: Please review this part. May be different from
                    // neptune.

                    // Generate 32 bytes and interpret them as a big-endian
                    // integer. Bytes are big-endian to
                    // agree with the integers generated by grain_random_bits in
                    // the reference implementation:
                    //
                    // def grain_random_bits(num_bits):
                    //     random_bits = [grain_gen.next() for i in range(0,
                    // num_bits)]     random_int =
                    // int("".join(str(i) for i in random_bits), 2)
                    //     return random_int
                    let mut repr = F::default().into_repr().to_bytes_be();
                    grain.get_next_bytes(repr.as_mut());
                    repr.reverse();
                    if let Some(f) = F::from_random_bytes(&repr) {
                        round_constants.push(f);
                        false
                    } else {
                        true
                    }
                } {}
            }
        }
        _ => {
            panic!("Only prime fields are supported.");
        }
    }
    round_constants
}

fn append_bits<T: Into<u128>>(vec: &mut VecDeque<bool>, n: usize, from: T) {
    let val = from.into();
    for i in (0..n).rev() {
        vec.push_back((val >> i) & 1 != 0);
    }
}

// adapted from: https://github.com/filecoin-project/neptune/blob/master/src/round_constants.rs
struct GrainLFSR {
    state: VecDeque<bool>,
    field_size: u16,
}

impl GrainLFSR {
    pub fn new(initial_sequence: VecDeque<bool>, field_size: u16) -> Self {
        assert_eq!(
            initial_sequence.len(),
            80,
            "Initial Sequence must be 80 bits"
        );
        let mut g = GrainLFSR {
            state: initial_sequence,
            field_size,
        };
        (0..160).for_each(|_| {
            g.generate_new_bit();
        });
        assert_eq!(80, g.state.len());
        g
    }

    fn generate_new_bit(&mut self) -> bool {
        let new_bit = self.bit(62)
            ^ self.bit(51)
            ^ self.bit(38)
            ^ self.bit(23)
            ^ self.bit(13)
            ^ self.bit(0);
        self.state.pop_front();
        self.state.push_back(new_bit);
        new_bit
    }

    fn bit(&self, index: usize) -> bool {
        self.state[index]
    }

    fn next_byte(&mut self, bit_count: usize) -> u8 {
        // Accumulate bits from most to least significant, so the most
        // significant bit is the one generated first by the bit stream
        let mut acc: u8 = 0;
        self.take(bit_count).for_each(|bit| {
            acc <<= 1;
            if bit {
                acc += 1;
            }
        });

        acc
    }

    fn get_next_bytes(&mut self, result: &mut [u8]) {
        let remainder_bits = self.field_size as usize % 8;
        // Prime fields will always have remainder bits,
        // but other field types could be supported in the future.
        if remainder_bits > 0 {
            // If there is an unfull byte, it should be the first.
            // Subsequent bytes are packed into result in the order generated.
            result[0] = self.next_byte(remainder_bits);
        } else {
            result[0] = self.next_byte(8);
        }

        // First byte is already set
        for item in result.iter_mut().skip(1) {
            *item = self.next_byte(8)
        }
    }
}

impl Iterator for GrainLFSR {
    type Item = bool;

    // TO BE checked
    fn next(&mut self) -> Option<Self::Item> {
        let mut new_bit = self.generate_new_bit();
        while !new_bit {
            let _new_bit = self.generate_new_bit();
            new_bit = self.generate_new_bit();
        }
        new_bit = self.generate_new_bit();
        Some(new_bit)
    }
}

// TODO: TO BE TESTED!
